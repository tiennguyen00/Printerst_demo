{"version":3,"file":"main.umd.js","sources":["../src/constants.ts","../src/createFetchWrapper.ts","../src/generateCollectionEndpoints.ts","../src/typeCheckers.ts","../src/generatePhotoEndpoints.ts","../src/generateVideoEndpoints.ts","../src/createClient.ts"],"sourcesContent":["export const photoBaseUrl = \"https://api.pexels.com/v1/\";\nexport const videoBaseUrl = \"https://api.pexels.com/videos/\";\nexport const collectionBaseUrl = \"https://api.pexels.com/v1/collections/\";\nexport const testApiKey = process.env.API_KEY as string;\n","import { Params } from \"./types\";\nimport { photoBaseUrl, videoBaseUrl, collectionBaseUrl } from \"./constants\";\n\ntype AllowedTypes = \"photo\" | \"video\" | \"collections\";\n\nconst baseUrls: { [T in AllowedTypes]: string } = {\n  photo: photoBaseUrl,\n  video: videoBaseUrl,\n  collections: collectionBaseUrl,\n};\n\nexport default function createFetchWrapper(apiKey: string, type: AllowedTypes) {\n  const options = {\n    method: \"GET\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": \"Pexels/JavaScript\",\n      Authorization: apiKey,\n    },\n  };\n\n  const baseUrl = baseUrls[type];\n\n  return <T extends Params>(path: string, params?: T) =>\n    fetch(\n      `${baseUrl}${path}?${stringifyParams(params || {})}`,\n      options\n    ).then((response) => response.json());\n}\n\nfunction stringifyParams<T extends Params>(params: T) {\n  return Object.keys(params)\n    .map((key) => `${key}=${params[key]}`)\n    .join(\"&\");\n}\n","import createFetchWrapper from \"./createFetchWrapper\";\nimport { Collection, PaginationParams, ErrorResponse, Medium } from \"./types\";\n\ntype AllReturn =\n  | {\n      page: number;\n      per_page: number;\n      collections: Collection[];\n    }\n  | ErrorResponse;\n\ntype MediaReturn =\n  | {\n      page: number;\n      per_page: number;\n      media: (Medium & { type: \"Video\" | \"Photo\" })[];\n    }\n  | ErrorResponse;\n\nexport default function generateCollectionEndpoints(apiKey: string) {\n  const fetchWrapper = createFetchWrapper(apiKey, \"collections\");\n\n  return {\n    all(params: PaginationParams): Promise<AllReturn> {\n      return fetchWrapper(\"\", params);\n    },\n    media({\n      id,\n      ...params\n    }: PaginationParams & {\n      id: string | number;\n      type?: \"photos\" | \"videos\";\n    }): Promise<MediaReturn> {\n      return fetchWrapper(`${id}`, params);\n    },\n  };\n}\n","import { Photos, Videos, ErrorResponse } from \"./types\";\n\n/**\n * A helper function to determine if the object is a valid Photo response\n */\nexport function isPhotos(x: any): x is Photos {\n  return !!(x && x.photos);\n}\n\n/**\n * A helper function to determine if the object is a valid Video response\n */\nexport function isVideos(x: any): x is Videos {\n  return !!(x && x.videos);\n}\n\n/**\n * A helper function to determine if the object was an error response\n */\nexport function isError(x: any): x is ErrorResponse {\n  return !!x.error;\n}\n","import createFetchWrapper from \"./createFetchWrapper\";\nimport {\n  Photo,\n  PaginationParams,\n  ErrorResponse,\n  Photos,\n  PhotosWithTotalResults,\n} from \"./types\";\nimport { isPhotos } from \"./typeCheckers\";\n\ntype SearchReturn = PhotosWithTotalResults | ErrorResponse;\ntype CuratedReturn = Photos | ErrorResponse;\ntype ShowReturn = Photo | ErrorResponse;\ntype RandomReturn = Photo | ErrorResponse;\n\nexport default function generatePhotoEndpoints(apiKey: string) {\n  const fetchWrapper = createFetchWrapper(apiKey, \"photo\");\n\n  return {\n    search(\n      params: PaginationParams & { query: string }\n    ): Promise<SearchReturn> {\n      return fetchWrapper(`/search`, params);\n    },\n    curated(params: PaginationParams = {}): Promise<CuratedReturn> {\n      return fetchWrapper(`/curated`, params);\n    },\n    show({ id }: { id: string | number }): Promise<ShowReturn> {\n      return fetchWrapper(`/photos/${id}`);\n    },\n    async random(): Promise<RandomReturn> {\n      const randomPage = Math.floor(1000 * Math.random());\n      const response = await this.curated({ page: randomPage, per_page: 1 });\n\n      if (isPhotos(response)) {\n        return response.photos[0] as RandomReturn;\n      }\n\n      return response as ErrorResponse;\n    },\n  };\n}\n","import createFetchWrapper from \"./createFetchWrapper\";\nimport {\n  PaginationParams,\n  ErrorResponse,\n  Video,\n  Videos,\n  VideoFilterParams,\n} from \"./types\";\n\ntype SearchReturn = Videos | ErrorResponse;\ntype PopularReturn = Videos | ErrorResponse;\ntype ShowReturn = Video;\n\nexport default function generatePhotoEndpoints(apiKey: string) {\n  const fetchWrapper = createFetchWrapper(apiKey, \"video\");\n\n  return {\n    search(\n      params: PaginationParams &\n        VideoFilterParams & {\n          query: string;\n        }\n    ): Promise<SearchReturn> {\n      return fetchWrapper(`/search`, params);\n    },\n    popular(\n      params: PaginationParams & VideoFilterParams = {}\n    ): Promise<PopularReturn> {\n      return fetchWrapper(`/popular`, params);\n    },\n    show({ id }: { id: string | number }): Promise<ShowReturn> {\n      return fetchWrapper(`/videos/${id}`);\n    },\n  };\n}\n","require(\"isomorphic-fetch\");\n\nimport generateCollectionEndpoints from \"./generateCollectionEndpoints\";\nimport generatePhotoEndpoints from \"./generatePhotoEndpoints\";\nimport generateVideoEndpoints from \"./generateVideoEndpoints\";\nimport * as typeCheckers from \"./typeCheckers\";\n\nexport default function createClient(apiKey: string) {\n  if (!apiKey || typeof apiKey !== \"string\") {\n    throw new TypeError(\n      `An ApiKey must be provided when initiating the Pexel's client.`\n    );\n  }\n\n  return {\n    typeCheckers,\n    photos: generatePhotoEndpoints(apiKey),\n    videos: generateVideoEndpoints(apiKey),\n    collections: generateCollectionEndpoints(apiKey),\n  };\n}\n"],"names":["process","baseUrls","photo","video","collections","createFetchWrapper","apiKey","type","options","method","headers","Accept","Content-Type","User-Agent","Authorization","baseUrl","path","params","fetch","Object","keys","map","key","join","stringifyParams","then","response","json","generateCollectionEndpoints","fetchWrapper","all","media","id","isPhotos","x","photos","videos","error","generatePhotoEndpoints","search","curated","show","random","randomPage","Math","floor","this","page","per_page","popular","require","TypeError","typeCheckers","generateVideoEndpoints"],"mappings":"sLAG0BA,YCEpBC,EAA4C,CAChDC,MDN0B,6BCO1BC,MDN0B,iCCO1BC,YDN+B,0CCSjC,SAAwBC,EAAmBC,EAAgBC,GACzD,IAAMC,EAAU,CACdC,OAAQ,MACRC,QAAS,CACPC,OAAQ,mBACRC,eAAgB,mBAChBC,aAAc,oBACdC,cAAeR,IAIbS,EAAUd,EAASM,GAEzB,gBAA0BS,EAAcC,UACtCC,SACKH,EAAUC,MAKnB,SAA2CC,GACzC,OAAOE,OAAOC,KAAKH,GAChBI,IAAI,SAACC,UAAWA,MAAOL,EAAOK,KAC9BC,KAAK,KARiBC,CAAgBP,GAAU,IAC/CT,GACAiB,KAAK,SAACC,UAAaA,EAASC,mBCTVC,EAA4BtB,GAClD,IAAMuB,EAAexB,EAAmBC,EAAQ,eAEhD,MAAO,CACLwB,aAAIb,GACF,OAAOY,EAAa,GAAIZ,IAE1Bc,sBACEC,IAAAA,GACGf,+IAKH,OAAOY,KAAgBG,EAAMf,cC5BnBgB,EAASC,GACvB,SAAUA,IAAKA,EAAEC,kDAMnB,SAAyBD,GACvB,SAAUA,IAAKA,EAAEE,0BAMKF,GACtB,QAASA,EAAEG,iBCLWC,EAAuBhC,GAC7C,IAAMuB,EAAexB,EAAmBC,EAAQ,SAEhD,MAAO,CACLiC,gBACEtB,GAEA,OAAOY,YAAwBZ,IAEjCuB,iBAAQvB,GACN,gBADMA,IAAAA,EAA2B,IAC1BY,aAAyBZ,IAElCwB,iBACE,OAAOZ,eADFG,KAGDU,0BACEC,EAAaC,KAAKC,MAAM,IAAOD,KAAKF,iCACnBI,KAAKN,QAAQ,CAAEO,KAAMJ,EAAYK,SAAU,mBAA5DtB,UAEFO,EAASP,GACJA,EAASS,OAAO,GAGlBT,IApBJ,8CCLeY,EAAuBhC,GAC7C,IAAMuB,EAAexB,EAAmBC,EAAQ,SAEhD,MAAO,CACLiC,gBACEtB,GAKA,OAAOY,YAAwBZ,IAEjCgC,iBACEhC,GAEA,gBAFAA,IAAAA,EAA+C,IAExCY,aAAyBZ,IAElCwB,iBACE,OAAOZ,eADFG,MC9BXkB,QAAQ,4CAO6B5C,GACnC,IAAKA,GAA4B,iBAAXA,EACpB,UAAU6C,4EAKZ,MAAO,CACLC,aAAAA,EACAjB,OAAQG,EAAuBhC,GAC/B8B,OAAQiB,EAAuB/C,GAC/BF,YAAawB,EAA4BtB"}